library(caret)
library(randomForest)
library(tidyverse)
library(ggplot2)
library(earth)
library(kernlab)
library(dplyr)
library(corrplot)
library(Metrics)
theme_set(theme_minimal())
#Set seed to reproduce samples
seed <- 123
df <- read.csv("parkinsons_updrs.data.csv")
head(df)
str(df)
summary(df)
dim(df)
sum(is.na(df))
# Age distribution
ggplot(df, aes(x = age)) +
geom_histogram(binwidth = 5, fill = "blue", color = "black") +
theme_minimal() +
labs(title = "Age Distribution of Patients", x = "Age", y = "Count")
# Total UPDRS distribution
ggplot(df, aes(x = total_UPDRS)) +
geom_histogram(binwidth = 5, fill = "green", color = "black") +
theme_minimal() +
labs(title = "Distribution of Total UPDRS Scores", x = "Total UPDRS", y = "Count")
# Age vs. Total UPDRS
ggplot(df, aes(x = age, y = total_UPDRS)) +
geom_point(alpha = 0.5) +
theme_minimal() +
labs(title = "Age vs. Total UPDRS", x = "Age", y = "Total UPDRS")
# Count the number of males and females
sex_count <- df %>%
group_by(sex) %>%
summarise(count = n())
# Convert 'sex' to factor for better labeling
sex_count$sex <- factor(sex_count$sex, labels = c("Female", "Male"))
# Create a bar plot for the distribution of males and females
ggplot(sex_count, aes(x = sex, y = count, fill = sex)) +
geom_bar(stat = "identity") +
theme_minimal() +
labs(title = "Distribution of Males and Females", x = "Sex", y = "Count") +
scale_fill_manual(values = c("Female" = "pink", "Male" = "blue"))
# gather numeric columns
numeric_cols <- sapply(df, is.numeric)
# normalizing the numerical features
df[numeric_cols] <- lapply(df[numeric_cols], scale)
# determine the minimum count
min_count <- min(sex_count$count)
# downsample the majority class
df_downsample <- df %>%
group_by(sex) %>%
sample_n(min_count)
# Visualizing new amount of male and female
# Count the number of males and females after downsampling
sex_count_downsampled <- df_downsample %>%
group_by(sex) %>%
summarise(count = n())
# Convert 'sex' to factor for better labeling
sex_count_downsampled$sex <- factor(sex_count_downsampled$sex, labels = c("Female", "Male"))
# Create a bar plot for the distribution of males and females after downsampling
ggplot(sex_count_downsampled, aes(x = sex, y = count, fill = sex)) +
geom_bar(stat = "identity") +
theme_minimal() +
labs(title = "Distribution of Males and Females after Downsampling", x = "Sex", y = "Count") +
scale_fill_manual(values = c("Female" = "pink", "Male" = "blue"))
correlations <- cor(df)
corrplot(correlations, order = "hclust")
print(correlations)
# find highly correlated predictors
highCorr <- findCorrelation(correlations, cutoff = 0.80)
cat("The amount of high correlations:", length(highCorr), "\n")
cat("\n")
cat ("Values with high correlations: \n")
cat(highCorr)
# removing high correlations
filtered_df <- df[,-highCorr]
# correlation heatmap again
correlationsFiltered <- cor(filtered_df)
corrplot(correlationsFiltered, order = "hclust")
# Print dimensions of filtered dataset and original dataset
cat("Original data dimensions:", dim(df), "\n")
cat("Filtered data dimensions:", dim(filtered_df), "\n")
# Boxplot for each numerical variable
boxplot(df[,numeric_cols], outline=TRUE, col="lightblue", main="Boxplot of Numerical Variables")
# Function to detect outliers using IQR method
detect_outliers <- function(x) {
q1 <- quantile(x, 0.25)
q3 <- quantile(x, 0.75)
iqr <- q3 - q1
lower_bound <- q1 - 1.5 * iqr
upper_bound <- q3 + 1.5 * iqr
outliers <- x < lower_bound | x > upper_bound
return(outliers)
}
# Apply the function to each numerical variable
outliers <- apply(df[,numeric_cols], 2, detect_outliers)
# Count the number of outliers for each variable
outlier_counts <- colSums(outliers)
outlier_counts
# Visualize the distribution of total_UPDRS with density plot
ggplot(filtered_df, aes(x = total_UPDRS)) +
geom_density(fill = "green", color = "black") +
theme_minimal() +
labs(title = "Density Plot of Total UPDRS Scores", x = "Total UPDRS", y = "Density")
# Select predictor variables (all columns except total_UPDRS)
predictor_vars <- filtered_df[, !colnames(filtered_df) %in% "total_UPDRS"]
# Create scatter plots for each predictor variable against total_UPDRS
for (var in colnames(predictor_vars)) {
p <- ggplot(filtered_df, aes_string(x = var, y = "total_UPDRS")) +
geom_point(alpha = 0.5) +
theme_minimal() +
labs(title = paste("Scatter Plot of", var, "vs. Total UPDRS"),
x = var, y = "Total UPDRS")
print(p)
}
# Split the data into training and test sets (80% train, 20% test)
set.seed(seed)
trainIndex <- createDataPartition(filtered_df$total_UPDRS, p = 0.8, list = FALSE)
df_train <- filtered_df[trainIndex, ]
df_test <- filtered_df[-trainIndex, ]
# Print dimensions of training and test sets
cat("Training data dimensions:", dim(df_train), "\n")
cat("Test data dimensions:", dim(df_test), "\n")
# train linear moddel
linear_model <- lm(total_UPDRS ~ .,
data = df_train)
linear_model
# predict linear model
linear_predictions <- predict(linear_model,
df_test)
# set seed for reproducibiltiy
set.seed(seed)
# train random forest model
rf_model <- randomForest(total_UPDRS ~ .,
data = df_train,
importance = TRUE,
ntree = 500)
rf_model
# predict random forest model
rf_predictions <- predict(rf_model, df_test)
# set seed for reproducibiltiy
set.seed(seed)
# train SVM model
svm_model <- ksvm(total_UPDRS ~ .,
data = df_train,
kernel = "rbfdot")
svm_model
# predict SVM model
svm_predictions <- predict(svm_model,
df_test)
# set seed for reproducibiltiy
set.seed(seed)
# train MARS model
mars_model <- earth(total_UPDRS ~ ., data = df_train)
mars_model
# predict MARS model
mars_predictions <- predict(mars_model, df_test)
# set seed for reproducibiltiy
set.seed(seed)
# train GBM model
gbm_model <- train(total_UPDRS ~ .,
data = df_train,
method = "gbm",
trControl = trainControl(method = "cv", number = 5))
yes
# set seed for reproducibiltiy
set.seed(seed)
# train GBM model
gbm_model <- train(total_UPDRS ~ .,
data = df_train,
method = "gbm",
trControl = trainControl(method = "cv", number = 5))
gbm_model
# predict GBM model
gbm_predictions <- predict(gbm_model, df_test)
# set seed for reproducibiltiy
set.seed(seed)
# train NNET model
nn_model <- train(total_UPDRS ~ .,
data = df_train,
method = "nnet",
trControl = trainControl(method = "cv", number = 5),
linout = TRUE, trace = FALSE)
nn_model
# predict NNET model
nn_predictions <- predict(nn_model, df_test)
